# Principles of Evolution

December 28, 2025

Nature is the world's oldest and most successful engineer.
To understand how the Finches project works, we first look at the major pillars of Biological Evolution

### Variation

Individuals within populations have slightly different traits (some are faster, some are a different color).

### Inheritance

Traits are passed down from parents to offspring.

### Selection 

Individuals with more helpful traits are more likely to have more offspring in the next generations.

### Time

Over many generations tiny changes add up to radical transformations.

---

# Genetic Algorithms

- **Initialization:** Create a population of random solutions.
- **LOOP:**
  + **Evaluation:** Score each solution based on how well it solves the task (Fitness).
  + **Selection:** Choose the highest-scoring solutions to be parents.
  + **Crossover:** Combine parent solutions to create offspring.
  + **Mutation:** Apply random changes to offspring.
  + **Replacement:** Swap offspring into the population.

### Example

In 19th-century England, the Peppered Moth provided a perfect real-world example of evolution in action.

- **The Environment:** Tree trunks were originally light-colored.
- **The Variation:** Most moths were light in color (very few were darker due to rare mutations).
- **The Shift:** Industrial soot turned the trees black.
- **The Result:** Birds ate the visible light moths, while the dark moths survived to reproduce.


### Example - Genetic Algorithm

```
 1  from random import randint
 2
 3  individuals = 32
 4  generations = 128
 5  # initialization
 6  population = [randint(245, 250) for i in range(individuals)]
 7  for g in range(generations):
 8      # evaluation
 9      parents = sorted(population)
10      for i in range(individuals):
11          # selection
12          parent_x = parents[randint(0, individuals//2)]
13          parent_y = parents[randint(0, individuals//2)]
14          # crossover
15          offspring = (parent_x + parent_y) // 2
16          # mutation
17          offspring += randint(-5, 5)
18          # replacement
19          population[i] = max(0, min(offspring, 255))
20      print(g, population)
```

### Example - Generation 1

```

[
    242, 245, 243, 248, 248, 250, 248, 247,
    252, 250, 250, 250, 244, 246, 250, 246,
    244, 247, 246, 248, 251, 245, 251, 247,
    245, 244, 245, 245, 243, 247, 246, 242
]

```

### Example - Generation 16

```

[
    203, 201, 201, 205, 198, 197, 194, 202,
    198, 201, 197, 205, 193, 201, 204, 204,
    202, 203, 197, 206, 198, 200, 199, 197,
    205, 203, 200, 196, 200, 199, 195, 203
]

```

### Example - Generation 128

```

[
    0, 0, 2, 0, 0, 0, 2, 4,
    3, 0, 0, 0, 2, 0, 0, 0,
    0, 0, 0, 1, 2, 0, 1, 0,
    5, 0, 5, 0, 0, 0, 2, 0
]

```

---

# Linear Genetic Programming

Traditional genetic programming use Tree-based represented for there solution.

Linear Genetic Programming is a subset of genetic programming where computer programs are represented as a linear sequence of instructions.

```
 1  AND R4, R2, R3
 2  OR  R0, R1, R4
 3  AND R0, R3, R0
 4  AND R4, R2, R4  # this is a non-effective instruction (intron)
 5  OR  R0, R0, R2
```

---

# Optimizing The Instruction Set For Program Evolvability

### Traditional Instruction Format

**Large Variable-Length Instructions:** Instructions can vary significantly in size (e.g., 1 byte vs. 15 bytes).
If a mutation or crossover happens at the "wrong" bit,
it shifts the entire program,
turning the remaining code into gibberish.

**Invalid Opcodes and Registers:** Most systems have "illegal" bit patterns.
A random mutation is likely to create an instruction the CPU doesn't understand,
causing the program to crash (Segfault) and ending that "life" prematurely.

### Finches Instruction Format

**Compact Uniform 16-bit Instruction Format:** Every single instruction is exactly 16 bits.
This ensures perfect alignment.
You can cut, paste,
or swap any block of code,
and the instructions will always line up perfectly.

**Total Bit-Mapping:** There is no such thing as an invalid instruction.
Every possible combination of bits maps to a valid opcode,
a result register,
and source registers.

**The Result:** Even a program generated by "rolling dice" is a valid program that can be executed and scored.
Evolution never hits a "dead end" due to syntax errors.

|OPCODE |RESULT|FIRST|SECOND|
|-------|------|-----|------|
|[15-12]|[11-8]|[7-4]|[3-0] |

|OPCODE|Mnemonic|Pseudocode                                                       |
|------|--------|-----------------------------------------------------------------|
|0000  |AD      |register[RESULT] = register[FIRST] + register[SECOND]            |
|0001  |SB      |register[RESULT] = register[FIRST] - register[SECOND]            |
|0010  |ML      |register[RESULT] = register[FIRST] * register[SECOND]            |
|0011  |DV      |register[RESULT] = register[FIRST] / register[SECOND]            |
|0100  |PW      |register[RESULT] = pow(register[FIRST], register[SECOND])        |
|0101  |SQ      |register[RESULT] = sqrt(register[FIRST])                         |
|0110  |EX      |register[RESULT] = exp(register[FIRST])                          |
|0111  |LG      |register[RESULT] = log(register[FIRST])                          |
|1000  |SN      |register[RESULT] = sin(register[FIRST])                          |
|1001  |AS      |register[RESULT] = asin(register[FIRST])                         |
|1010  |CS      |register[RESULT] = cos(register[FIRST])                          |
|1011  |AC      |register[RESULT] = acos(register[FIRST])                         |
|1100  |MN      |register[RESULT] = min(register[FIRST], register[SECOND])        |
|1101  |MX      |register[RESULT] = max(register[FIRST], register[SECOND])        |
|1110  |LT      |register[RESULT] = 1 if register[FIRST] < register[SECOND] else 0|
|1111  |GT      |register[RESULT] = 1 if register[FIRST] > register[SECOND] else 0|

**Inclusion of inverse operations** (e.g. addition and subtraction, multiplication and division, sine and arcsine) creates a more uniform and balanced search space.
This allows instructions to be effectively "undone" or counteracted, which further contributes to a smoother solution landscape and enhances finches ability to explore.

### Traditional Control Flow

Traditional LGP often rely on branching control flow operations,
which easily break under genetic crossover and mutation, leading to a rougher fitness landscape.

```
 1  R1 = 0
 2  if R0 < 42
 3      R1 = -1
 4  if R0 > 42
 5      R1 = 1
```

```
 1  CMP R0, 42
 2  MOV R1 -1
 3  JL  7       # mutation here
 4  INC R0, R0
 5  JZ  7       # mutation here
 6  INC R0, R0
```

### Finches Traditional Control

Finches employs branchless programming techniques for its control flow.
This approach integrates control flow directly into computations.
By avoiding explicit branching,
LGP can incrementally evolve conditional flow logic through symbolic regression,
resulting in a significantly smoother solution landscape.

```
 1  R1 = (R0 < 42) * -1 + (R0 > 42) * 1
```

```
 1  LT  R2, R0, 42
 2  MUL R2, R2, -1
 3  GT  R1, R0, 42
 4  ADD R1, R1, R2
```

**Only contains arithmetic comparison operations** (such as min, max, <, and >).
This design choice provides a more incremental and continuous path for forming control flow logic when compared to all-or-nothing boolean operations
(like AND, OR, NOT).

---

# Optimizing The Genetic Algorithm for Evolvability

### Beyond Crossover: Fission & Transfer

- **The Problem with Crossover:** Imagine taking two different cake recipes, cutting them in half, and taping them together. You probably won't get a cake.
- **The Finches Solution:**
  + Fission: A high-performing "parent" simply clones itself.
  + Transfer: A small, random "block" of code is taken from a random donor and inserted into the offspring.
- **The Result:** This maintains the "working" core of a program while introducing small, functional snippets from others.

### Selection & Replacement Strategy

- **Tournament Selection:** Two neighboring individuals are compared.
- **The "Loser" is Replaced:**
  + The individual with the lower fitness is removed.
  + If fitness is tied, the longer program is removed (this keeps the code efficient).
- **Robust Local Exploration:** By selecting "neighbors" the algorithm ensures that the population doesn't all become identical too quickly, allowing different "pockets" of solutions to evolve independently.

### Design Philosophy: The "Smooth" Path

- **Simplified Overhead:** Simple selection and replacement mean more CPU cycles are spent on evolving and less on managing the population.
- **Reduced Memory Allocation:** By reusing existing program slots in the population, Finches runs extremely fast.
- **Computational Efficiency:** By turning "if/else" logic into math and "crossover" into "transfer," we move away from a jagged landscape of crashes and toward a smooth landscape of incremental improvements.

# Use Cases

- **Reverse Engineering** - Infer hidden logic from observed inputs and outputs, even when source code or hardware is unavailable.

- **Data Compression** - Evolve compact functions that approximate large datasets, allowing for significant reductions in storage.

# Use Finches

Run the Makefile to build finches:
```
$ make
go build -o finches
```

Create a **examples.csv** file where each line contains **ONE to EIGHT example inputs followed by ONE expected output**.

A **examples.csv** file for a three input function:
```
2.175702178,3.4978843946,2.8679357454,42.7201735336
3.727866762,4.6107086188,-3.4225095225,70.7890623513
-1.6914281809,-4.2087394179,2.475850641,39.3184982846
0.4793454968,3.6758416723,-2.3773138762,24.9995146063
2.0264537683,-0.8547617596,-4.7856914722,68.217804457
-3.1671669278,-0.8226972678,-3.4907083169,49.9335397455
0.5837987947,-4.7796641015,-4.1819232422,51.3009229327
-3.8194496568,-0.2562750524,4.7254929564,77.767960022
-3.2942570245,2.4734392713,1.5534051521,-0.7628296637
-0.2975551098,-4.5018374909,0.5470816154,8.8745394888
0.8429004267,2.4176065495,-2.1438009046,22.0203497133
-0.8824430962,0.9755978955,0.7106055863,5.6755047387
-2.0692284587,-1.6842422241,-2.8357669579,38.1641150601
0.557997777,-4.339746829,-0.99579524,2.5736885366
4.4987170938,2.2281464346,4.1271759253,71.6496271677
3.9986431397,1.2608830478,-0.2652827417,11.2961243578
```

The above file contains 16 input-output examples, ideally you want at least 256 examples.

Run finches on **examples.csv**, adjust the **--generations** and or **--individuals** counts if the resulting ```function.go``` is not accurate enough:
```
$ ./finches examples.csv --generations 4096 --individuals 1024
100.0% -> function.go
```

Genetic algorithms at their core rely on randomness so your result may vary.

Finches will evolve a function to fit the input-output examples and create a **function.go** file with equivalent Go code.

Executing **function.go** with the first example from **examples.csv**:
```
$ go run function.go 2.175702178 3.4978843946 2.8679357454
42.720173532676014
```
