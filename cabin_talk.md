# Principles of Evolution 

Nature is the world's oldest and most successful engineer.
To understand how the Finches project works, we first look at the major pillars of Biological Evolution

### Variation

Individuals within populations have slightly different traits (some are faster, some are a different color).

### Inheritance

Traits are passed down from parents to offspring.

### Selection 

Individuals with more helpful traits are more likely to have more offspring in the next generations.

### Time

Over many generations tiny changes add up to radical transformations.

---

# Genetic Algorithms

- **Initialization:** Create a population of random solutions.
- **LOOP:**
  + **Evaluation:** Score each solution based on how well it solves the task (Fitness).
  + **Selection:** Choose the highest-scoring solutions to be parents.
  + **Crossover:** Combine parent solutions to create offspring.
  + **Mutation:** Apply random changes to offspring.
  + **Replacement:** Swap offspring into the population.

### Example

In 19th-century England, the Peppered Moth provided a perfect real-world example of evolution in action.

- **The Environment:** Tree trunks were originally light-colored.
- **The Variation:** Most moths were light in color (very few were darker due to rare mutations).
- **The Shift:** Industrial soot turned the trees black.
- **The Result:** Birds ate the visible light moths, while the dark moths survived to reproduce.


### Example - Genetic Algorithm

```
 1  from random import randint
 2
 3  individuals = 32
 4  generations = 128
 5  # initialization
 6  population = [randint(245, 250) for i in range(individuals)]
 7  for g in range(generations):
 8      # evaluation
 9      parents = sorted(population)
10      for i in range(individuals):
11          # selection
12          parent_x = parents[randint(0, individuals//2)]
13          parent_y = parents[randint(0, individuals//2)]
14          # crossover
15          offspring = (parent_x + parent_y) // 2
16          # mutation
17          offspring += randint(-5, 5)
18          # replacement
19          population[i] = max(0, min(offspring, 255))
20      print(g, population)
```

### Example - Generation 1

```

[
    242, 245, 243, 248, 248, 250, 248, 247,
    252, 250, 250, 250, 244, 246, 250, 246,
    244, 247, 246, 248, 251, 245, 251, 247,
    245, 244, 245, 245, 243, 247, 246, 242
]

```

### Example - Generation 16

```

[
    203, 201, 201, 205, 198, 197, 194, 202,
    198, 201, 197, 205, 193, 201, 204, 204,
    202, 203, 197, 206, 198, 200, 199, 197,
    205, 203, 200, 196, 200, 199, 195, 203
]

```

### Example - Generation 128

```

[
    0, 0, 2, 0, 0, 0, 2, 4,
    3, 0, 0, 0, 2, 0, 0, 0,
    0, 0, 0, 1, 2, 0, 1, 0,
    5, 0, 5, 0, 0, 0, 2, 0
]

```

---

# Linear Genetic Programming

Traditional genetic programming use Tree-based represented for there solution.

Linear Genetic Programming is a subset of genetic programming where computer programs are represented as a linear sequence of instructions.

```
 1  AND R4, R2, R3
 2  OR  R0, R1, R4
 3  AND R0, R3, R0
 4  AND R4, R2, R4  # this is a non-effective instruction (intron)
 5  OR  R0, R0, R2
```

---

# Optimizing The Instruction Set For Program Evolvability

### Traditional Instruction Format

**Large Variable-Length Instructions:** Instructions can vary significantly in size (e.g., 1 byte vs. 15 bytes).
If a mutation or crossover happens at the "wrong" bit,
it shifts the entire program,
turning the remaining code into gibberish.

**Invalid Opcodes and Registers:** Most systems have "illegal" bit patterns.
A random mutation is likely to create an instruction the CPU doesn't understand,
causing the program to crash (Segfault) and ending that "life" prematurely.

### Finches Instruction Format

**Compact Uniform 16-bit Instruction Format:** Every single instruction is exactly 16 bits.
This ensures perfect alignment.
You can cut, paste,
or swap any block of code,
and the instructions will always line up perfectly.

**Total Bit-Mapping:** There is no such thing as an invalid instruction.
Every possible combination of bits maps to a valid opcode,
a result register,
and source registers.

**The Result:** Even a program generated by "rolling dice" is a valid program that can be executed and scored.
Evolution never hits a "dead end" due to syntax errors.

|OPCODE |RESULT|FIRST|SECOND|
|-------|------|-----|------|
|[15-12]|[11-8]|[7-4]|[3-0] |

|OPCODE|Mnemonic|Pseudocode                                                       |
|------|--------|-----------------------------------------------------------------|
|0000  |AD      |register[RESULT] = register[FIRST] + register[SECOND]            |
|0001  |SB      |register[RESULT] = register[FIRST] - register[SECOND]            |
|0010  |ML      |register[RESULT] = register[FIRST] * register[SECOND]            |
|0011  |DV      |register[RESULT] = register[FIRST] / register[SECOND]            |
|0100  |PW      |register[RESULT] = pow(register[FIRST], register[SECOND])        |
|0101  |SQ      |register[RESULT] = sqrt(register[FIRST])                         |
|0110  |EX      |register[RESULT] = exp(register[FIRST])                          |
|0111  |LG      |register[RESULT] = log(register[FIRST])                          |
|1000  |SN      |register[RESULT] = sin(register[FIRST])                          |
|1001  |AS      |register[RESULT] = asin(register[FIRST])                         |
|1010  |CS      |register[RESULT] = cos(register[FIRST])                          |
|1011  |AC      |register[RESULT] = acos(register[FIRST])                         |
|1100  |MN      |register[RESULT] = min(register[FIRST], register[SECOND])        |
|1101  |MX      |register[RESULT] = max(register[FIRST], register[SECOND])        |
|1110  |LT      |register[RESULT] = 1 if register[FIRST] < register[SECOND] else 0|
|1111  |GT      |register[RESULT] = 1 if register[FIRST] > register[SECOND] else 0|

**Inclusion of inverse operations** (e.g. addition and subtraction, multiplication and division, sine and arcsine) creates a more uniform and balanced search space.
This allows instructions to be effectively "undone" or counteracted, which further contributes to a smoother solution landscape and enhances finches ability to explore.

### Traditional Control Flow

Traditional LGP often rely on branching control flow operations,
which easily break under genetic crossover and mutation, leading to a rougher fitness landscape.

```
 1  R1 = 0
 2  if R0 < 42
 3      R1 = -1
 4  if R0 > 42
 5      R1 = 1
```

```
 1  CMP R0, 42
 2  MOV R1 -1
 3  JL  7       # mutation here
 4  INC R0, R0
 5  JZ  7       # mutation here
 6  INC R0, R0
```

### Finches Traditional Control

Finches employs branchless programming techniques for its control flow.
This approach integrates control flow directly into computations.
By avoiding explicit branching,
LGP can incrementally evolve conditional flow logic through symbolic regression,
resulting in a significantly smoother solution landscape.

```
 1  R1 = (R0 < 42) * -1 + (R0 > 42) * 1
```

```
 1  LT  R2, R0, 42
 2  MUL R2, R2, -1
 3  GT  R1, R0, 42
 4  ADD R1, R1, R2
```

**Only contains arithmetic comparison operations** (such as min, max, <, and >).
This design choice provides a more incremental and continuous path for forming control flow logic when compared to all-or-nothing boolean operations
(like AND, OR, NOT).

---

# Optimizing The Genetic Algorithm for Evolvability

